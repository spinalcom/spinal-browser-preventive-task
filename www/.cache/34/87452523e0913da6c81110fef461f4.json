{"id":"../../../node_modules/spinal-env-viewer-context-geographic-service/build/index.js","dependencies":[{"name":"/home/spinalcom/Desktop/multi-maquette/preventive/spinal-browser-preventive-task/package.json","includedInParent":true,"mtime":1567517512841},{"name":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-context-geographic-service/package.json","includedInParent":true,"mtime":1567158417415},{"name":"spinal-env-viewer-graph-service","loc":{"line":7,"column":43},"parent":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-graph-service/dist/index.js"},{"name":"spinal-models-building-elements","loc":{"line":9,"column":44},"parent":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-models-building-elements/build/index.js"},{"name":"./constants","loc":{"line":11,"column":25},"parent":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-context-geographic-service/build/constants.js"},{"name":"spinal-core-connectorjs_type","loc":{"line":15,"column":42},"parent":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Desktop/multi-maquette/node_modules/spinal-core-connectorjs_type/dist/SpinalModel.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _spinalEnvViewerGraphService = require(\"spinal-env-viewer-graph-service\");\n\nvar _spinalModelsBuildingElements = require(\"spinal-models-building-elements\");\n\nvar _constants = require(\"./constants\");\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _spinalCoreConnectorjs_type = require(\"spinal-core-connectorjs_type\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// import bimobjService from 'spinal-env-viewer-plugin-bimobjectservice';\n\nconst bimobjService = window.spinal.BimObjectService;\n\nconst GeographicContext = {\n  constants: constants,\n\n  /**\n   * Returns the child type of the type given as parameter.\n   * @param {string} parentType\n   * @return {string} Child type\n   */\n  getChildType(parentType) {\n    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);\n\n    if (parentTypeIndex === -1) {\n      return \"\";\n    }\n\n    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n  },\n\n  /**\n   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.\n   * @param {string} contextName\n   * @returns {Boolean}\n   */\n  createContext(contextName) {\n    if (typeof contextName !== \"string\") {\n      throw Error(\"contextName must be a string\");\n    }\n\n    const context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);\n\n    if (typeof context !== \"undefined\") return false;\n\n    _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, constants.CONTEXT_TYPE, new _spinalModelsBuildingElements.AbstractElement(contextName));\n\n    return true;\n  },\n\n  /**\n   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} elementName - The AbstactElement Name\n   * @returns {Boolean}\n   */\n  addAbstractElement(context, node, elementName) {\n    const parentType = node.type.get();\n    const childType = this.getChildType(parentType);\n\n    if (!childType) {\n      throw Error(`${parentType} is not a valid type in geographical context`);\n    }\n\n    const childRelation = constants.MAP_TYPE_RELATION.get(childType);\n\n    const childNode = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n      name: elementName,\n      type: childType\n    }, new _spinalModelsBuildingElements.AbstractElement(elementName));\n    _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id.get(), childRelation, _spinalEnvViewerGraphService.SPINAL_RELATION_TYPE);\n\n    this.addToReferenceContext(childNode);\n\n    return true;\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} buildingName - Building Name\n   */\n  addBuilding(context, node, buildingName) {\n    return GeographicContext.addAbstractElement(context, node, buildingName);\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} floorName - the floor Name\n   */\n  addFloor(context, node, floorName) {\n    return GeographicContext.addAbstractElement(context, node, floorName);\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} zoneName - Zone name\n   */\n  addZone(context, node, zoneName) {\n    return GeographicContext.addAbstractElement(context, node, zoneName);\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} roomName - Room Name\n   */\n  addRoom(context, node, roomName) {\n    return GeographicContext.addAbstractElement(context, node, roomName);\n  },\n\n  /**\n   * it uses bimObject service to add all dbIds passed as parameters.\n   * the parameter dbIds can be a simple dbIds or a list of dbIds.\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {Number | Array<Number>} dbIds - Can be\n   */\n  addBimElement(context, node, dbIds, model) {\n\n    if (!Array.isArray(dbIds)) dbIds = [dbIds];\n\n    // le bimObjectService\n    // let c = SpinalGraphService.getRealNode(context.id.get());\n    // let n = SpinalGraphService.getRealNode(node.id.get());\n\n    let contextId = context.id.get();\n    let parentId = node.id.get();\n\n    dbIds.forEach(element => {\n      // bimobjService.addBIMObject(c, n, element.dbId, element.name);\n      window.spinal.BimObjectService.addBIMObject(contextId, parentId, element.dbId, element.name, model);\n    });\n  },\n\n  _getReferenceContextName(nodeId) {\n    let node = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId);\n\n    switch (node.type.get()) {\n      case constants.SITE_TYPE:\n        return {\n          name: constants.SITE_REFERENCE_CONTEXT,\n          relation: constants.SITE_RELATION\n        };\n      case constants.BUILDING_TYPE:\n        return {\n          name: constants.BUILDING_REFERENCE_CONTEXT,\n          relation: constants.BUILDING_RELATION\n        };\n\n      case constants.FLOOR_TYPE:\n        return {\n          name: constants.FLOOR_REFERENCE_CONTEXT,\n          relation: constants.FLOOR_RELATION\n        };\n\n      case constants.ZONE_TYPE:\n        return {\n          name: constants.ZONE_REFERENCE_CONTEXT,\n          relation: constants.ZONE_RELATION\n        };\n\n      case constants.ROOM_TYPE:\n        return {\n          name: constants.ROOM_REFERENCE_CONTEXT,\n          relation: constants.ROOM_RELATION\n        };\n\n      default:\n        return undefined;\n    }\n  },\n\n  /**\n   *\n   * @param {string} nodeId\n   */\n  addToReferenceContext(nodeId) {\n    let obj = this._getReferenceContextName(nodeId);\n\n    if (typeof obj !== \"undefined\") {\n      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(obj.name);\n\n      if (typeof context !== \"undefined\") {\n\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(context.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);\n      }\n\n      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(obj.name, obj.name.replace(\".\", \"\"), new _spinalCoreConnectorjs_type.Model({\n        name: obj.name\n      })).then(c => {\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(c.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);\n      });\n    }\n  },\n\n  /**\n   *\n   * @param {string} contextId\n   */\n  addContextToReference(contextId) {\n    let context = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(contextId);\n\n    if (typeof context !== \"undefined\") {\n      return context.forEach(constants.GEOGRAPHIC_RELATIONS, node => {\n        _spinalEnvViewerGraphService.SpinalGraphService._addNode(node);\n        this.addToReferenceContext(node.info.id.get());\n      });\n    }\n  }\n\n};\n\nexports.default = GeographicContext;\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/index.js"],"names":["constants","bimobjService","window","spinal","BimObjectService","GeographicContext","getChildType","parentType","parentTypeIndex","GEOGRAPHIC_TYPES_ORDER","indexOf","createContext","contextName","Error","context","SpinalGraphService","getContext","addContext","CONTEXT_TYPE","AbstractElement","addAbstractElement","node","elementName","type","get","childType","childRelation","MAP_TYPE_RELATION","childNode","createNode","name","addChildInContext","id","SPINAL_RELATION_TYPE","addToReferenceContext","addBuilding","buildingName","addFloor","floorName","addZone","zoneName","addRoom","roomName","addBimElement","dbIds","model","Array","isArray","contextId","parentId","forEach","element","addBIMObject","dbId","_getReferenceContextName","nodeId","getInfo","SITE_TYPE","SITE_REFERENCE_CONTEXT","relation","SITE_RELATION","BUILDING_TYPE","BUILDING_REFERENCE_CONTEXT","BUILDING_RELATION","FLOOR_TYPE","FLOOR_REFERENCE_CONTEXT","FLOOR_RELATION","ZONE_TYPE","ZONE_REFERENCE_CONTEXT","ZONE_RELATION","ROOM_TYPE","ROOM_REFERENCE_CONTEXT","ROOM_RELATION","undefined","obj","addChild","info","SPINAL_RELATION_LST_PTR_TYPE","replace","Model","then","c","addContextToReference","getRealNode","GEOGRAPHIC_RELATIONS","_addNode"],"mappings":"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","file":"index.js","sourcesContent":["import {\n  SPINAL_RELATION_TYPE,\n  SPINAL_RELATION_LST_PTR_TYPE,\n  SpinalGraphService\n} from \"spinal-env-viewer-graph-service\";\nimport {\n  AbstractElement\n} from \"spinal-models-building-elements\";\n\n// import bimobjService from 'spinal-env-viewer-plugin-bimobjectservice';\n\nconst bimobjService = window.spinal.BimObjectService;\n\nimport * as constants from \"./constants\";\nimport {\n  Model\n} from \"spinal-core-connectorjs_type\";\n\nconst GeographicContext = {\n  constants: constants,\n\n  /**\n   * Returns the child type of the type given as parameter.\n   * @param {string} parentType\n   * @return {string} Child type\n   */\n  getChildType(parentType) {\n    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(\n      parentType);\n\n    if (parentTypeIndex === -1) {\n      return \"\";\n    }\n\n    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n  },\n\n  /**\n   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.\n   * @param {string} contextName\n   * @returns {Boolean}\n   */\n  createContext(contextName) {\n    if (typeof contextName !== \"string\") {\n      throw Error(\n        \"contextName must be a string\");\n    }\n\n    const context = SpinalGraphService.getContext(contextName);\n\n    if (typeof context !== \"undefined\") return false;\n\n\n    SpinalGraphService.addContext(contextName,\n      constants.CONTEXT_TYPE,\n      new AbstractElement(contextName));\n\n    return true;\n  },\n\n  /**\n   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} elementName - The AbstactElement Name\n   * @returns {Boolean}\n   */\n  addAbstractElement(context, node, elementName) {\n    const parentType = node.type.get();\n    const childType = this.getChildType(parentType);\n\n    if (!childType) {\n      throw Error(\n        `${parentType} is not a valid type in geographical context`\n      );\n    }\n\n    const childRelation = constants.MAP_TYPE_RELATION.get(childType);\n\n    const childNode = SpinalGraphService.createNode({\n        name: elementName,\n        type: childType\n      },\n      new AbstractElement(elementName)\n    );\n    SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id\n      .get(), childRelation, SPINAL_RELATION_TYPE);\n\n    this.addToReferenceContext(childNode);\n\n    return true;\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} buildingName - Building Name\n   */\n  addBuilding(context, node, buildingName) {\n    return GeographicContext.addAbstractElement(context, node, buildingName);\n  },\n\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} floorName - the floor Name\n   */\n  addFloor(context, node, floorName) {\n    return GeographicContext.addAbstractElement(context, node, floorName);\n  },\n\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} zoneName - Zone name\n   */\n  addZone(context, node, zoneName) {\n    return GeographicContext.addAbstractElement(context, node, zoneName);\n  },\n\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} roomName - Room Name\n   */\n  addRoom(context, node, roomName) {\n    return GeographicContext.addAbstractElement(context, node, roomName);\n  },\n\n  /**\n   * it uses bimObject service to add all dbIds passed as parameters.\n   * the parameter dbIds can be a simple dbIds or a list of dbIds.\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {Number | Array<Number>} dbIds - Can be\n   */\n  addBimElement(context, node, dbIds, model) {\n\n    if (!Array.isArray(dbIds)) dbIds = [dbIds];\n\n\n    // le bimObjectService\n    // let c = SpinalGraphService.getRealNode(context.id.get());\n    // let n = SpinalGraphService.getRealNode(node.id.get());\n\n    let contextId = context.id.get();\n    let parentId = node.id.get();\n\n    dbIds.forEach(element => {\n      // bimobjService.addBIMObject(c, n, element.dbId, element.name);\n      window.spinal.BimObjectService.addBIMObject(contextId, parentId,\n        element.dbId,\n        element.name, model)\n    });\n  },\n\n\n  _getReferenceContextName(nodeId) {\n    let node = SpinalGraphService.getInfo(nodeId);\n\n    switch (node.type.get()) {\n      case constants.SITE_TYPE:\n        return {\n          name: constants.SITE_REFERENCE_CONTEXT,\n            relation: constants.SITE_RELATION\n        };\n      case constants.BUILDING_TYPE:\n        return {\n          name: constants.BUILDING_REFERENCE_CONTEXT,\n            relation: constants.BUILDING_RELATION\n        };\n\n      case constants.FLOOR_TYPE:\n        return {\n          name: constants.FLOOR_REFERENCE_CONTEXT,\n            relation: constants.FLOOR_RELATION\n        };\n\n      case constants.ZONE_TYPE:\n        return {\n          name: constants.ZONE_REFERENCE_CONTEXT,\n            relation: constants.ZONE_RELATION\n        };\n\n      case constants.ROOM_TYPE:\n        return {\n          name: constants.ROOM_REFERENCE_CONTEXT,\n            relation: constants.ROOM_RELATION\n        };\n\n      default:\n        return undefined;\n    }\n  },\n\n  /**\n   *\n   * @param {string} nodeId\n   */\n  addToReferenceContext(nodeId) {\n    let obj = this._getReferenceContextName(nodeId);\n\n    if (typeof obj !== \"undefined\") {\n      let context = SpinalGraphService.getContext(obj.name);\n\n      if (typeof context !== \"undefined\") {\n\n        return SpinalGraphService.addChild(context.info.id.get(), nodeId,\n          obj.relation,\n          SPINAL_RELATION_LST_PTR_TYPE);\n      }\n\n      return SpinalGraphService.addContext(obj.name, obj.name.replace(\n        \".\", \"\"), new Model({\n        name: obj.name\n      })).then(c => {\n        return SpinalGraphService.addChild(c.info.id.get(), nodeId,\n          obj.relation,\n          SPINAL_RELATION_LST_PTR_TYPE);\n      });\n\n\n    }\n\n  },\n\n  /**\n   *\n   * @param {string} contextId\n   */\n  addContextToReference(contextId) {\n    let context = SpinalGraphService.getRealNode(contextId);\n\n    if (typeof context !== \"undefined\") {\n      return context.forEach(constants.GEOGRAPHIC_RELATIONS, (node) => {\n        SpinalGraphService._addNode(node);\n        this.addToReferenceContext(node.info.id.get());\n      })\n    }\n\n  }\n\n};\n\nexport default GeographicContext;"]}},"error":null,"hash":"dee751edf7c8573374c124ec0419d512","cacheData":{"env":{}}}